// Copyright (c) 2016 Brandon Thomas <bt@brand.io>, <echelon@gmail.com>

use protocol::Begin;
use protocol::COMMAND_PING;
use protocol::COMMAND_PREPARE;
use protocol::DacResponse;
use std::io::Read;
use std::io::Write;
use std::io;
use std::net::IpAddr;
use std::net::TcpStream;

pub struct Dac {
  ip_address: IpAddr,
  stream: TcpStream,
}

impl Dac {

  /// CTOR.
  pub fn new(ip_address: IpAddr) -> Dac {
    let stream = TcpStream::connect((ip_address, 7765u16)).unwrap(); // FIXME
    Dac {
      ip_address: ip_address,
      stream: stream,
    }
  }

  /// Stream points generated by a function.
  /// The function takes the number of points it needs to generate.
  pub fn play_function<F>(&mut self, make_points: F) -> ()
      where F: Fn(u16) -> Vec<u8> {
    println!("\n");

    let mut response = self.read_response().unwrap();
    println!("Response: {:?}", response);

    self.try_prepare(response);

    let mut started = false;

    loop {
      let num_points = 1799 - response.status.buffer_fullness;

      println!("Sending {} points", num_points);

      let points = make_points(num_points);

      println!("\nSend data");

      response = self.write_serialized_points(&points).unwrap(); // FIXME

      println!("Response: {:?}", response);

      if !response.is_ack() {
        println!("Failure!");
        return;
      }

      if !started {
        println!("\nSend begin");
        let response = self.begin().unwrap();
        println!("Response: {:?}", response);
        if !response.is_ack() {
          println!("Failure!");
          return;
        }

        started = true;
      }
    }
  }

  fn hello(&mut self) -> Result<DacResponse, io::Error> {
    println!("Write hello");
    let cmd = [ COMMAND_PING ];
    self.stream.write(&cmd).unwrap(); // FIXME

    println!("Read hello ack");
    //let mut buf = [0; 2048];
    //self.stream.read(&mut buf).unwrap(); // FIXME
    self.read_response()
  }

  fn prepare(&mut self) -> Result<DacResponse, io::Error> {
    println!("Write prepare");
    let cmd = [ COMMAND_PREPARE ];
    self.stream.write(&cmd).unwrap(); // FIXME

    println!("Read prepare ack");
    //let mut buf = [0; 2048];
    //self.stream.read(&mut buf).unwrap(); // FIXME
    self.read_response()
  }

  fn begin(&mut self) -> Result<DacResponse, io::Error> {
    println!("Write begin");
    let cmd = Begin { low_water_mark: 0, point_rate: 30_000 };
    self.stream.write(&cmd.serialize()).unwrap(); // FIXME

    println!("Read begin ack");
    //let mut buf = [0; 2048];
    //self.stream.read(&mut buf).unwrap(); // FIXME
    self.read_response()
  }

  fn try_prepare(&mut self, response: DacResponse) {
    if response.status.playback_flags != 0x0 && response.status.playback_flags != 0x1 {
      println!("\nBad playback flags, must PREPARE: {}", response.status.playback_flags);
      println!("\nSend prepare");
      let resp = self.prepare().unwrap();
      println!("Response: {:?}", response);
      if !resp.is_ack() {
        println!("Failure!");
        panic!("Non-ACK received");
      }
      return;
    }

    if response.status.playback_state == 0x2 {
      println!("\nBad playback_state, must PREPARE: {}", response.status.playback_state);
      println!("\nSend prepare");
      let resp = self.prepare().unwrap();
      println!("Response: {:?}", response);
      if !resp.is_ack() {
        println!("Failure!");
        panic!("Non-ACK received");
      }
    }
  }

  // TODO:
  // Sends (3 + 18*n) bytes.
  // fn write_data(&mut self, num_points: u16) -> Result<DacResponse, io::Error>

  /// Write a slice of points to the DAC.
  pub fn write_serialized_points(&mut self, serialized_points: &[u8])
                                 -> Result<DacResponse, io::Error> {
    println!("Write data");
    self.stream.write(&serialized_points)?;

    println!("Read data ack");
    self.read_response()
  }

  fn read(&mut self) {
    println!("read() ... ");
    let mut buf = [0; 22];
    match self.stream.read(&mut buf) {
      Ok(size) => {
        println!("Read bytes: {}", size);
      },
      Err(_) => {
        println!("Read error!");
        return;
      }
    }

    let response = DacResponse::parse(&buf);

    match response {
      Ok(r) => println!("DacResponse: {:?}", r),
      Err(e) => println!("Error: {:?}", e),
    };
  }

  fn read_response(&mut self) -> Result<DacResponse, io::Error> {
    println!("read_response() ... ");
    let mut buf = [0; 22];

    match self.stream.read(&mut buf) {
      Ok(_size) => {},
      Err(e) => {
        return Err(e);
      },
    }

    DacResponse::parse(&buf)
  }
}

